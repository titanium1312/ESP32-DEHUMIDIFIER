<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ESP32 Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background-color: #121212; /* üåë n·ªÅn t·ªëi */
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #chartContainer {
      width: 100%;
      height: 100%;
      padding: 10px;
      box-sizing: border-box;
    }
    #status {
      text-align: center;
      font-size: 14px;
      color: #bbb;
      margin-bottom: 5px;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <div id="chartContainer">
    <div id="status">üîÑ ƒêang t·∫£i d·ªØ li·ªáu...</div>
    <canvas id="espChart"></canvas>
  </div>

  <script>
  const apiUrl = "https://script.google.com/macros/s/AKfycbxhPINgsxcHQn12TCW2h6nbAX4HPPB9wGGCFNXvTs6QcKmfwqekvlZIt13troVh2Qcj/exec";
  let chart;

  function createChart(labels, tempData, humData, relayData) {
    const ctx = document.getElementById('espChart').getContext('2d');
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: 'üå°Ô∏è Nhi·ªát ƒë·ªô (¬∞C)',
            data: tempData,
            borderColor: '#ff5252',
            backgroundColor: 'rgba(255,82,82,0.2)',
            fill: true,
            tension: 0.3,
            yAxisID: 'y'
          },
          {
            label: 'üíß ƒê·ªô ·∫©m (%)',
            data: humData,
            borderColor: '#42a5f5',
            backgroundColor: 'rgba(66,165,245,0.2)',
            fill: true,
            tension: 0.3,
            yAxisID: 'y'
          },
          {
            label: '‚ö° Relay',
            data: relayData,
            borderColor: '#00e676',
            borderWidth: 2,
            stepped: true,
            pointRadius: 3,
            fill: false,
            yAxisID: 'y1'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: {
            position: 'bottom',
            labels: { color: '#ddd' }
          }
        },
        scales: {
          x: {
            ticks: {
              color: '#aaa',
              maxRotation: 0,
              autoSkip: true,
              maxTicksLimit: 10,
              callback: (value, index) => {
                const date = new Date(labels[index]);
                return date.toLocaleTimeString("vi-VN", { hour: '2-digit', minute: '2-digit' });
              }
            },
            grid: { color: '#333' }
          },
          y: {
            title: { display: true, text: '¬∞C / %', color: '#ccc' },
            ticks: { color: '#aaa' },
            grid: { color: '#333' }
          },
          y1: {
            position: 'right',
            grid: { drawOnChartArea: false },
            ticks: {
              color: '#aaa',
              stepSize: 1,
              callback: v => v === 1 ? 'ON' : 'OFF'
            }
          }
        }
      }
    });
  }

  async function loadDataAndDraw() {
    try {
      document.getElementById("status").innerText = "üîÑ ƒêang t·∫£i d·ªØ li·ªáu...";
      const response = await fetch(apiUrl);
      const data = await response.json();

      // ch·ªâ l·∫•y 100 m·∫´u cu·ªëi ƒë·ªÉ m∆∞·ª£t h∆°n
      const latest = data.slice(-100);
      const labels = latest.map(r => new Date(r.time));
      const tempData = latest.map(r => r.temp);
      const humData = latest.map(r => r.hum);
      const relayData = latest.map(r => r.relay);

      if (!chart) {
        createChart(labels, tempData, humData, relayData);
      } else {
        chart.data.labels = labels;
        chart.data.datasets[0].data = tempData;
        chart.data.datasets[1].data = humData;
        chart.data.datasets[2].data = relayData;
        chart.update();
      }

      document.getElementById("status").innerText =
        "‚úÖ C·∫≠p nh·∫≠t l√∫c: " + new Date().toLocaleTimeString("vi-VN");
    } catch (err) {
      document.getElementById("status").innerText = "‚ö†Ô∏è L·ªói t·∫£i d·ªØ li·ªáu!";
      console.error("L·ªói:", err);
    }
  }

  // G·ªçi App Inventor reload
  function reloadData() {
    console.log("üì± App Inventor y√™u c·∫ßu reload...");
    loadDataAndDraw();
  }

  // L·∫ßn ƒë·∫ßu load
  loadDataAndDraw();

  // Theo d√µi WebViewString m·ªói 3 gi√¢y
  setInterval(() => {
    if (window.AppInventor) {
      const cmd = window.AppInventor.getWebViewString();
      if (cmd === "reloadData") {
        reloadData();
        window.AppInventor.setWebViewString("");
      }
    }
  }, 3000);
  </script>
</body>
</html>
